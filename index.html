<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiLoop Galaxy - Interactive Wikipedia Graph Explorer</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Explore Wikipedia articles through an interactive graph visualization. Discover connections between topics with WikiLoop Galaxy's dynamic network visualization tool.">
    <meta name="keywords" content="Wikipedia, graph visualization, network analysis, article connections, interactive exploration, D3.js">
    <meta name="author" content="WikiLoop">
    <meta name="robots" content="index, follow">
    
    <!-- OpenGraph Meta Tags -->
    <meta property="og:title" content="WikiLoop Galaxy - Interactive Wikipedia Graph Explorer">
    <meta property="og:description" content="Explore Wikipedia articles through an interactive graph visualization. Discover connections between topics with WikiLoop Galaxy's dynamic network visualization tool.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://galaxy.wikiloop.org/">
    <meta property="og:image" content="https://galaxy.wikiloop.org/assets/ogImage.png">
    <meta property="og:image:alt" content="WikiLoop Galaxy - Interactive Wikipedia Graph Visualization">
    <meta property="og:site_name" content="WikiLoop Galaxy">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="WikiLoop Galaxy - Interactive Wikipedia Graph Explorer">
    <meta name="twitter:description" content="Explore Wikipedia articles through an interactive graph visualization. Discover connections between topics with WikiLoop Galaxy's dynamic network visualization tool.">
    <meta name="twitter:image" content="https://galaxy.wikiloop.org/assets/ogImage.png">
    <meta name="twitter:image:alt" content="WikiLoop Galaxy - Interactive Wikipedia Graph Visualization">
    
    <!-- Additional SEO -->
    <link rel="canonical" href="https://galaxy.wikiloop.org/">
    <meta name="theme-color" content="#4ecdc4">
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="assets/favicon-48x48.png">
    <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="assets/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="assets/android-chrome-512x512.png">
    <link rel="mask-icon" href="assets/logo.svg" color="#4ecdc4">
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .graph-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .node {
            cursor: pointer;
            stroke: #333;
            stroke-width: 2px;
        }
        
        .node.root {
            fill: #FFFFFF;
            stroke: #4CAF50;
            stroke-width: 3px;
        }
        
        .node.missing {
            fill: #f44336;
        }
        
        .node.first-degree {
            fill: #4ecdc4;
        }
        
        .node.second-degree {
            fill: #45b7d1;
        }
        
        .node.vital {
            fill: #FFD700;
            stroke: #FF6B00;
            stroke-width: 3px;
        }
        
        .node.featured {
            fill: #32CD32;
            stroke: #228B22;
            stroke-width: 2px;
        }
        
        .node.good {
            fill: #87CEEB;
            stroke: #4682B4;
            stroke-width: 2px;
        }
        
        .node.expandable {
            stroke: #FFC107;
            stroke-width: 3px;
            cursor: pointer;
        }
        
        .node.expanding {
            stroke: #FF9800;
            stroke-width: 4px;
            animation: pulse 1s ease-in-out infinite alternate;
        }
        
        .node.processing {
            stroke: #00BCD4;
            stroke-width: 5px;
            animation: glow 0.8s ease-in-out infinite alternate;
            filter: drop-shadow(0 0 8px #00BCD4);
        }
        
        @keyframes pulse {
            from { stroke-opacity: 0.8; }
            to { stroke-opacity: 0.3; }
        }
        
        @keyframes glow {
            from { 
                stroke-opacity: 1;
                filter: drop-shadow(0 0 8px #00BCD4);
            }
            to { 
                stroke-opacity: 0.4;
                filter: drop-shadow(0 0 15px #00BCD4);
            }
        }
        
        .link {
            stroke: #555;
            stroke-width: 1px;
            stroke-opacity: 0.6;
        }
        
        .node-label {
            font-size: 12px;
            fill: #e0e0e0;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 350px;
            z-index: 1000;
        }
        
        .root-input-container {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .root-input {
            flex: 1;
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            margin-right: 8px;
        }
        
        .root-input:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        
        .go-button {
            background: #4ecdc4;
            color: #1a1a1a;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        
        .go-button:hover {
            background: #45b7d1;
        }
        
        .go-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            font-size: 14px;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        
        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #333;
            border-radius: 50%;
            border-top-color: #4ecdc4;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 300px;
        }
        
        .controls button {
            background: #4ecdc4;
            color: #1a1a1a;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 12px;
        }
        
        .controls button:hover {
            background: #45b7d1;
        }
        
        .help-text {
            font-size: 11px;
            color: #aaa;
            margin-top: 10px;
            line-height: 1.4;
        }
        
        .links-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            z-index: 1000;
        }
        
        .links-panel a {
            color: #4ecdc4;
            text-decoration: none;
            font-size: 14px;
            display: block;
            margin-bottom: 8px;
        }
        
        .links-panel a:hover {
            color: #45b7d1;
            text-decoration: underline;
        }
        
        .links-panel a:last-child {
            margin-bottom: 0;
        }
        
        .context-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            z-index: 2000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .context-menu-item {
            padding: 8px 16px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            transition: background-color 0.2s;
        }
        
        .context-menu-item:hover {
            background-color: #333;
        }
        
        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background-color: transparent;
        }
        
        .context-menu-icon {
            margin-right: 8px;
            width: 16px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="info-panel">
            <div class="status" id="status">
                <span class="loading"></span>
                Initializing...
            </div>
            <div class="root-input-container">
                <input type="text" class="root-input" id="root-input" placeholder="Enter Wikipedia article title" value="Artificial Intelligence">
                <button class="go-button" id="go-button" onclick="loadNewRoot()">Go</button>
            </div>
            <div>
                <strong>Nodes:</strong> <span id="node-count">0</span><br>
                <strong>Links:</strong> <span id="link-count">0</span>
            </div>
        </div>
        
        <div class="links-panel">
            <a href="https://github.com/wikiloop/galaxy" target="_blank">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 6px; vertical-align: text-bottom;">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                Source Code on GitHub
            </a>
            <a href="https://en.wikipedia.org/wiki/Wikipedia:WikiLoop_Galaxy" target="_blank">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 6px; vertical-align: text-bottom;">
                    <path d="M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm5.9 6.7c-.2 0-.4-.1-.6-.1-.4 0-.7.1-1.1.1-.7 0-1.4-.1-2.1-.2-.4-.1-.8-.1-1.2-.1-.3 0-.5 0-.8.1C6.8 6.9 5.6 7.2 4.2 7.5c-.3.1-.6.1-.9.2-.2 0-.3.1-.5.1-.1 0-.2 0-.3-.1-.1-.1-.1-.2-.1-.3 0-.2.1-.4.2-.6.2-.4.5-.8.8-1.1.4-.4.8-.8 1.3-1.1.5-.3 1-.5 1.6-.6.6-.1 1.2-.1 1.8 0 .6.1 1.2.3 1.7.6.5.3.9.7 1.3 1.1.3.3.6.7.8 1.1.1.2.2.4.2.6 0 .1 0 .2-.1.3-.1.1-.2.1-.3.1zm-1.8 2.8c-.3-.1-.6-.2-.9-.4-.3-.2-.6-.4-.8-.7-.2-.3-.4-.6-.5-.9-.1-.3-.2-.6-.2-.9 0-.3.1-.6.2-.9.1-.3.3-.6.5-.9.2-.3.5-.5.8-.7.3-.2.6-.3.9-.4.3-.1.6-.1.9 0 .3.1.6.2.9.4.3.2.6.4.8.7.2.3.4.6.5.9.1.3.2.6.2.9 0 .3-.1.6-.2.9-.1.3-.3.6-.5.9-.2.3-.5.5-.8.7-.3.2-.6.3-.9.4-.3.1-.6.1-.9 0z"/>
                </svg>
                WP:WikiLoop Galaxy
            </a>
        </div>
        
        <div class="controls">
            <button onclick="resetGraph()">Reset</button>
            <button onclick="pauseResume()" id="pause-btn">Pause</button>
            <div class="help-text">
                <strong>Click:</strong> Show context menu<br>
                <strong>Menu:</strong> Open page, Expand, Collapse, Set as root<br>
                <strong>Drag:</strong> Move nodes<br>
                <strong>Colors:</strong> ‚ö™ Root, üü° Vital, üü¢ Featured, üîµ Good, üîµ Links, üî¥ Missing
            </div>
        </div>
        
        <div class="graph-container">
            <svg id="graph"></svg>
        </div>
        
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="context-open">
                <span class="context-menu-icon">üîó</span>
                <span>Open Wikipedia Page</span>
            </div>
            <div class="context-menu-item" id="context-collapse">
                <span class="context-menu-icon">üîÑ</span>
                <span>Collapse (Remove Leaves)</span>
            </div>
            <div class="context-menu-item" id="context-expand">
                <span class="context-menu-icon">‚ûï</span>
                <span>Expand (10 more links)</span>
            </div>
            <div class="context-menu-item" id="context-set-root">
                <span class="context-menu-icon">üéØ</span>
                <span>Set as Root</span>
            </div>
        </div>
    </div>

    <script>
        // WikiLoop Galaxy - Interactive Wikipedia Graph Explorer
        class WikipediaGraph {
            constructor() {
                this.nodes = new Map();
                this.links = new Set();
                this.processedArticles = new Set();
                this.expandedNodes = new Set();
                this.queue = [];
                this.isProcessing = false;
                this.isPaused = false;
                this.contextMenu = null;
                this.selectedNode = null;
                
                // D3 setup
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.svg = d3.select("#graph")
                    .attr("width", this.width)
                    .attr("height", this.height);
                
                // Create zoom behavior
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on("zoom", (event) => {
                        this.container.attr("transform", event.transform);
                    });
                
                this.svg.call(this.zoom);
                
                // Create container for zoomable content
                this.container = this.svg.append("g");
                
                // Initialize simulation
                this.simulation = d3.forceSimulation()
                    .force("link", d3.forceLink().id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                    .force("collision", d3.forceCollide().radius(30));
                
                // Create link and node groups
                this.linkGroup = this.container.append("g").attr("class", "links");
                this.nodeGroup = this.container.append("g").attr("class", "nodes");
                
                // Start with hardcoded article
                this.startArticle = "Artificial_intelligence";
                this.initContextMenu();
                this.init();
            }
            
            initContextMenu() {
                this.contextMenu = document.getElementById('context-menu');
                
                // Add event listeners for context menu items
                document.getElementById('context-open').addEventListener('click', (event) => {
                    if (!event.target.closest('.context-menu-item').classList.contains('disabled')) {
                        this.openWikipediaPage();
                        this.hideContextMenu();
                    }
                });
                
                document.getElementById('context-collapse').addEventListener('click', (event) => {
                    if (!event.target.closest('.context-menu-item').classList.contains('disabled')) {
                        this.collapseNode();
                        this.hideContextMenu();
                    }
                });
                
                document.getElementById('context-expand').addEventListener('click', (event) => {
                    if (!event.target.closest('.context-menu-item').classList.contains('disabled')) {
                        this.expandSelectedNode();
                        this.hideContextMenu();
                    }
                });
                
                document.getElementById('context-set-root').addEventListener('click', (event) => {
                    if (!event.target.closest('.context-menu-item').classList.contains('disabled')) {
                        this.setAsRoot();
                        this.hideContextMenu();
                    }
                });
                
                // Hide context menu when clicking elsewhere
                document.addEventListener('click', (event) => {
                    if (!this.contextMenu.contains(event.target) && !event.target.closest('.node-group')) {
                        this.hideContextMenu();
                    }
                });
            }
            
            showContextMenu(event, node) {
                event.preventDefault();
                event.stopPropagation();
                
                this.selectedNode = node;
                this.contextMenu.style.display = 'block';
                this.contextMenu.style.left = `${event.pageX}px`;
                this.contextMenu.style.top = `${event.pageY}px`;
                
                // Update menu item states
                this.updateContextMenuState(node);
            }
            
            hideContextMenu() {
                this.contextMenu.style.display = 'none';
                this.selectedNode = null;
            }
            
            updateContextMenuState(node) {
                const collapseItem = document.getElementById('context-collapse');
                const expandItem = document.getElementById('context-expand');
                const setRootItem = document.getElementById('context-set-root');
                
                // Check if node can be collapsed (has leaf nodes)
                const hasLeafNodes = this.hasLeafNodes(node);
                collapseItem.classList.toggle('disabled', !hasLeafNodes);
                
                // Check if node can be expanded (not already expanded or missing)
                const canExpand = !this.expandedNodes.has(node.id) && node.type !== 'missing';
                expandItem.classList.toggle('disabled', !canExpand);
                
                // Check if node can be set as root (not already root)
                const canSetRoot = node.type !== 'root';
                setRootItem.classList.toggle('disabled', !canSetRoot);
            }
            
            hasLeafNodes(node) {
                // Check if this node has connections to leaf nodes (nodes with only one connection)
                const nodeConnections = this.getNodeConnections(node.id);
                return nodeConnections.some(connectedId => {
                    const connectedNode = this.nodes.get(connectedId);
                    return connectedNode && this.getNodeConnections(connectedId).length === 1;
                });
            }
            
            getNodeConnections(nodeId) {
                const connections = [];
                for (const linkId of this.links) {
                    const [source, target] = linkId.split('-');
                    if (source === nodeId) connections.push(target);
                    if (target === nodeId) connections.push(source);
                }
                return connections;
            }
            
            async init() {
                console.log("üöÄ Starting Wikipedia graph visualization");
                this.updateStatus("Loading root article...");
                
                // Get metadata for root article
                const rootMetadata = await this.getArticleMetadata(this.startArticle);
                
                // Add root node with metadata
                this.addNode(this.startArticle, "root", 0, rootMetadata);
                this.updateDisplay();
                
                // Queue the root article for processing
                const rootPriority = this.calculatePriority(rootMetadata, 0);
                this.queue.push({title: this.startArticle, degree: 0, priority: rootPriority});
                
                // Start processing
                this.processQueue();
            }
            
            calculatePriority(metadata, degree) {
                if (!metadata) return 0;
                
                const { importanceBonus = 0, editCount = 0, backlinkCount = 0 } = metadata;
                
                // Formula: (importance bonus + # of edits + # of backlinks) / degree from root
                // Avoid division by zero for root node
                const effectiveDegree = Math.max(degree, 1);
                const priority = (importanceBonus + editCount + backlinkCount) / effectiveDegree;
                
                return Math.round(priority);
            }

            addNode(title, type, degree, metadata = null) {
                if (!this.nodes.has(title)) {
                    const priority = this.calculatePriority(metadata, degree);
                    
                    this.nodes.set(title, {
                        id: title,
                        title: title,
                        type: type,
                        degree: degree,
                        expanded: false,
                        priority: priority,
                        importanceBonus: metadata?.importanceBonus || 0,
                        editCount: metadata?.editCount || 0,
                        backlinkCount: metadata?.backlinkCount || 0,
                        isVital: metadata?.isVital || false,
                        isFeatured: metadata?.isFeatured || false,
                        isGood: metadata?.isGood || false,
                        x: Math.random() * this.width,
                        y: Math.random() * this.height
                    });
                    console.log(`‚ûï Added node: ${title} (${type}, degree: ${degree}, priority: ${priority})`);
                }
            }
            
            openWikipediaPage() {
                if (this.selectedNode) {
                    console.log(`üîó Opening Wikipedia page: ${this.selectedNode.title}`);
                    window.open(`https://en.wikipedia.org/wiki/${this.selectedNode.title}`, '_blank');
                }
            }
            
            collapseNode() {
                if (!this.selectedNode) return;
                
                const nodeId = this.selectedNode.id;
                const connections = this.getNodeConnections(nodeId);
                
                // Find leaf nodes (nodes with only one connection to the selected node)
                const leafNodes = connections.filter(connectedId => {
                    const connectedNode = this.nodes.get(connectedId);
                    return connectedNode && this.getNodeConnections(connectedId).length === 1;
                });
                
                console.log(`üîÑ Collapsing ${leafNodes.length} leaf nodes from ${nodeId}`);
                
                // Remove leaf nodes and their links
                for (const leafId of leafNodes) {
                    this.nodes.delete(leafId);
                    this.expandedNodes.delete(leafId);
                    this.processedArticles.delete(leafId);
                    
                    // Remove all links involving this leaf node
                    const linksToRemove = [];
                    for (const linkId of this.links) {
                        const [source, target] = linkId.split('-');
                        if (source === leafId || target === leafId) {
                            linksToRemove.push(linkId);
                        }
                    }
                    
                    for (const linkId of linksToRemove) {
                        this.links.delete(linkId);
                    }
                }
                
                // Mark the selected node as not expanded so it can be expanded again
                this.expandedNodes.delete(nodeId);
                const node = this.nodes.get(nodeId);
                if (node) {
                    node.expanded = false;
                }
                
                this.updateDisplay();
            }
            
            expandSelectedNode() {
                if (this.selectedNode) {
                    this.expandNode(this.selectedNode.id);
                }
            }
            
            async setAsRoot() {
                if (this.selectedNode && this.selectedNode.type !== 'root') {
                    console.log(`üéØ Setting ${this.selectedNode.title} as new root`);
                    await this.loadNewRoot(this.selectedNode.title);
                }
            }

            async expandNode(title) {
                if (this.expandedNodes.has(title)) {
                    console.log(`‚è≠Ô∏è Node ${title} already expanded`);
                    return;
                }
                
                this.expandedNodes.add(title);
                const node = this.nodes.get(title);
                if (node) {
                    node.expanded = true;
                }
                
                console.log(`üîÑ Expanding node: ${title}`);
                this.updateNodeVisuals(title, 'expanding');
                
                try {
                    // Fetch both outbound and inbound links for expansion
                    const outboundLinks = await this.fetchArticleLinks(title, 'outbound');
                    const inboundLinks = await this.fetchArticleLinks(title, 'inbound');
                    
                    console.log(`üîç Expanding ${title}: ${outboundLinks.length} outbound, ${inboundLinks.length} inbound`);
                    
                    // Process outbound links
                    for (const link of outboundLinks) {
                        if (!this.nodes.has(link)) {
                            const pageExists = await this.checkPageExists(link);
                            if (pageExists) {
                                const metadata = await this.getArticleMetadata(link);
                                this.addNode(link, "first-degree", node.degree + 1, metadata);
                            } else {
                                this.addNode(link, "missing", node.degree + 1);
                            }
                        }
                        this.addLink(title, link);
                    }
                    
                    // Process inbound links
                    for (const link of inboundLinks) {
                        if (!this.nodes.has(link)) {
                            const pageExists = await this.checkPageExists(link);
                            if (pageExists) {
                                const metadata = await this.getArticleMetadata(link);
                                this.addNode(link, "first-degree", node.degree + 1, metadata);
                            } else {
                                this.addNode(link, "missing", node.degree + 1);
                            }
                        }
                        this.addLink(link, title);
                    }
                    
                    this.updateDisplay();
                    this.updateNodeVisuals(title, 'expandable');
                    
                } catch (error) {
                    console.error(`‚ùå Error expanding node ${title}:`, error);
                    this.updateNodeVisuals(title, 'expandable');
                }
            }
            
            updateNodeVisuals(title, state) {
                const nodeElement = this.nodeGroup.selectAll(".node-group")
                    .filter(d => d.id === title)
                    .select("circle");
                
                nodeElement.classed("expanding", state === "expanding");
                nodeElement.classed("processing", state === "processing");
                nodeElement.classed("expandable", state === "expandable");
            }
            
            addLink(source, target) {
                const linkId = `${source}-${target}`;
                if (!this.links.has(linkId) && this.nodes.has(source) && this.nodes.has(target)) {
                    this.links.add(linkId);
                    console.log(`üîó Added link: ${source} -> ${target}`);
                } else if (!this.nodes.has(source) || !this.nodes.has(target)) {
                    console.warn(`‚ö†Ô∏è Skipping link ${source} -> ${target}: missing node(s)`);
                }
            }
            
            async processQueue() {
                if (this.isPaused || this.queue.length === 0) {
                    this.updateStatus("Ready");
                    return;
                }
                
                this.isProcessing = true;
                
                // Sort queue by priority (highest priority first)
                this.queue.sort((a, b) => b.priority - a.priority);
                
                const current = this.queue.shift();
                
                if (this.processedArticles.has(current.title)) {
                    this.processQueue();
                    return;
                }
                
                this.processedArticles.add(current.title);
                
                try {
                    this.updateStatus(`Processing: ${current.title} (deg: ${current.degree}, pri: ${current.priority})`);
                    console.log(`üìñ Reading article: ${current.title} (degree: ${current.degree}, priority: ${current.priority})`);
                    
                    // Show processing state visual feedback
                    this.updateNodeVisuals(current.title, 'processing');
                    
                    // Fetch both outbound and inbound links
                    const outboundLinks = await this.fetchArticleLinks(current.title, 'outbound');
                    const inboundLinks = await this.fetchArticleLinks(current.title, 'inbound');
                    
                    console.log(`üîç Found ${outboundLinks.length} outbound and ${inboundLinks.length} inbound links in ${current.title}`);
                    
                    // Process outbound links
                    for (const link of outboundLinks) {
                        const nodeType = current.degree === 0 ? "first-degree" : "second-degree";
                        
                        // Check if the page exists before adding as node
                        const pageExists = await this.checkPageExists(link);
                        if (pageExists) {
                            // Get metadata for prioritization
                            const metadata = await this.getArticleMetadata(link);
                            this.addNode(link, nodeType, current.degree + 1, metadata);
                            this.addLink(current.title, link);
                            
                            // Queue for further processing if not too deep
                            if (current.degree < 1) {
                                const nextDegree = current.degree + 1;
                                const nextPriority = this.calculatePriority(metadata, nextDegree);
                                this.queue.push({title: link, degree: nextDegree, priority: nextPriority});
                            }
                        } else {
                            // Add missing page as red node
                            this.addNode(link, "missing", current.degree + 1);
                            this.addLink(current.title, link);
                            console.warn(`‚ö†Ô∏è Added missing page as red node: ${link}`);
                        }
                    }
                    
                    // Process inbound links
                    for (const link of inboundLinks) {
                        const nodeType = current.degree === 0 ? "first-degree" : "second-degree";
                        
                        // Check if the page exists before adding as node
                        const pageExists = await this.checkPageExists(link);
                        if (pageExists) {
                            // Get metadata for prioritization
                            const metadata = await this.getArticleMetadata(link);
                            this.addNode(link, nodeType, current.degree + 1, metadata);
                            this.addLink(link, current.title); // Note: reversed direction for inbound links
                            
                            // Queue for further processing if not too deep
                            if (current.degree < 1) {
                                const nextDegree = current.degree + 1;
                                const nextPriority = this.calculatePriority(metadata, nextDegree);
                                this.queue.push({title: link, degree: nextDegree, priority: nextPriority});
                            }
                        } else {
                            // Add missing page as red node
                            this.addNode(link, "missing", current.degree + 1);
                            this.addLink(link, current.title); // Note: reversed direction for inbound links
                            console.warn(`‚ö†Ô∏è Added missing inbound page as red node: ${link}`);
                        }
                    }
                    
                    this.updateDisplay();
                    
                    // Remove processing state and mark as expandable
                    this.updateNodeVisuals(current.title, 'expandable');
                    
                    // Process next item with delay
                    setTimeout(() => {
                        this.processQueue();
                    }, 500);
                    
                } catch (error) {
                    console.error(`‚ùå Error processing ${current.title}:`, error);
                    // Remove processing state on error
                    this.updateNodeVisuals(current.title, 'expandable');
                    setTimeout(() => {
                        this.processQueue();
                    }, 1000);
                }
            }
            
            async checkPageExists(title) {
                try {
                    const apiUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&titles=${encodeURIComponent(title)}`;
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        return false;
                    }
                    
                    const data = await response.json();
                    if (!data.query || !data.query.pages) {
                        return false;
                    }
                    
                    const pages = data.query.pages;
                    const pageId = Object.keys(pages)[0];
                    
                    // Check if page exists (negative page ID means it doesn't exist)
                    return pageId > 0 && !pages[pageId].missing;
                    
                } catch (error) {
                    console.error(`‚ùå Error checking page existence for ${title}:`, error);
                    return false;
                }
            }

            async getArticleMetadata(title) {
                try {
                    // Get categories, edit count, and backlinks
                    const categoryUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&titles=${encodeURIComponent(title)}&prop=categories|info&cllimit=max&inprop=watchers`;
                    const backlinkUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&list=backlinks&bltitle=${encodeURIComponent(title)}&bllimit=max&blfilterredir=nonredirects`;
                    const revisionUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&titles=${encodeURIComponent(title)}&prop=revisions&rvprop=ids&rvlimit=max`;
                    
                    const [categoryResponse, backlinkResponse, revisionResponse] = await Promise.all([
                        fetch(categoryUrl),
                        fetch(backlinkUrl),
                        fetch(revisionUrl)
                    ]);
                    
                    if (!categoryResponse.ok || !backlinkResponse.ok || !revisionResponse.ok) {
                        return { priority: 0, backlinkCount: 0, editCount: 0, categories: [] };
                    }
                    
                    const categoryData = await categoryResponse.json();
                    const backlinkData = await backlinkResponse.json();
                    const revisionData = await revisionResponse.json();
                    
                    // Extract categories
                    const categories = [];
                    if (categoryData.query && categoryData.query.pages) {
                        const pageId = Object.keys(categoryData.query.pages)[0];
                        const pageCategories = categoryData.query.pages[pageId].categories || [];
                        categories.push(...pageCategories.map(cat => cat.title));
                    }
                    
                    // Count backlinks
                    const backlinkCount = backlinkData.query && backlinkData.query.backlinks ? 
                        backlinkData.query.backlinks.length : 0;
                    
                    // Count edits (revisions)
                    let editCount = 0;
                    if (revisionData.query && revisionData.query.pages) {
                        const pageId = Object.keys(revisionData.query.pages)[0];
                        const revisions = revisionData.query.pages[pageId].revisions || [];
                        editCount = revisions.length;
                    }
                    
                    // Check for quality categories
                    const isVital = categories.some(cat => 
                        cat.includes('Vital articles') || 
                        cat.includes('Level-1 vital articles') || 
                        cat.includes('Level-2 vital articles') ||
                        cat.includes('Level-3 vital articles') ||
                        cat.includes('Level-4 vital articles') ||
                        cat.includes('Level-5 vital articles')
                    );
                    
                    const isFeatured = categories.some(cat => 
                        cat.includes('Featured articles') ||
                        cat.includes('Featured lists') ||
                        cat.includes('Featured article candidates')
                    );
                    
                    const isGood = categories.some(cat => 
                        cat.includes('Good articles') ||
                        cat.includes('Good article nominees')
                    );
                    
                    // Calculate importance bonus
                    let importanceBonus = 0;
                    if (isVital) {
                        importanceBonus = 3000; // Vital articles get highest bonus
                    } else if (isFeatured) {
                        importanceBonus = 2000; // Featured articles get high bonus
                    } else if (isGood) {
                        importanceBonus = 1000; // Good articles get medium bonus
                    }
                    
                    console.log(`üèÜ Article metadata for ${title}: importance=${importanceBonus}, edits=${editCount}, backlinks=${backlinkCount}, vital=${isVital}, featured=${isFeatured}, good=${isGood}`);
                    
                    return { 
                        importanceBonus,
                        editCount,
                        backlinkCount, 
                        categories,
                        isVital,
                        isFeatured,
                        isGood
                    };
                    
                } catch (error) {
                    console.error(`‚ùå Error fetching metadata for ${title}:`, error);
                    return { importanceBonus: 0, editCount: 0, backlinkCount: 0, categories: [], isVital: false, isFeatured: false, isGood: false };
                }
            }

            async fetchArticleLinks(title, direction = 'outbound') {
                try {
                    let apiUrl;
                    if (direction === 'outbound') {
                        // Get outbound links (links FROM this article)
                        apiUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&prop=links&titles=${encodeURIComponent(title)}&pllimit=20&plnamespace=0`;
                    } else {
                        // Get inbound links (links TO this article)
                        apiUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&list=backlinks&bltitle=${encodeURIComponent(title)}&bllimit=20&blnamespace=0`;
                    }
                    
                    console.log(`üåê Fetching ${direction} links from: ${apiUrl}`);
                    
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log(`üìä Raw API response for ${title} (${direction}):`, data);
                    
                    let linkTitles = [];
                    
                    if (direction === 'outbound') {
                        if (!data.query || !data.query.pages) {
                            console.warn(`‚ö†Ô∏è No pages found for ${title}`);
                            return [];
                        }
                        
                        // Extract outbound links from the response
                        const pages = data.query.pages;
                        const pageId = Object.keys(pages)[0];
                        const links = pages[pageId].links || [];
                        
                        linkTitles = links.map(link => link.title.replace(/ /g, '_')).filter(title => {
                            return !title.startsWith('Category:') && 
                                   !title.startsWith('Template:') && 
                                   !title.startsWith('File:') &&
                                   !title.startsWith('Help:') &&
                                   !title.startsWith('Wikipedia:');
                        });
                    } else {
                        // Extract inbound links (backlinks)
                        if (!data.query || !data.query.backlinks) {
                            console.warn(`‚ö†Ô∏è No backlinks found for ${title}`);
                            return [];
                        }
                        
                        linkTitles = data.query.backlinks.map(link => link.title.replace(/ /g, '_')).filter(title => {
                            return !title.startsWith('Category:') && 
                                   !title.startsWith('Template:') && 
                                   !title.startsWith('File:') &&
                                   !title.startsWith('Help:') &&
                                   !title.startsWith('Wikipedia:');
                        });
                    }
                    
                    console.log(`üîó Extracted ${linkTitles.length} valid ${direction} links from ${title}`);
                    return linkTitles.slice(0, 10); // Limit to 10 links
                    
                } catch (error) {
                    console.error(`‚ùå Failed to fetch ${direction} links for ${title}:`, error);
                    return [];
                }
            }
            
            updateDisplay() {
                const nodesArray = Array.from(this.nodes.values());
                const linksArray = Array.from(this.links).map(linkId => {
                    const [source, target] = linkId.split('-');
                    return {source, target};
                }).filter(link => {
                    // Only include links where both nodes exist
                    const sourceExists = this.nodes.has(link.source);
                    const targetExists = this.nodes.has(link.target);
                    if (!sourceExists || !targetExists) {
                        console.warn(`‚ö†Ô∏è Filtering out link ${link.source} -> ${link.target}: missing node(s)`);
                        return false;
                    }
                    return true;
                });
                
                // Update links
                const linkSelection = this.linkGroup
                    .selectAll(".link")
                    .data(linksArray, d => `${d.source}-${d.target}`);
                
                linkSelection.enter()
                    .append("line")
                    .attr("class", "link");
                
                linkSelection.exit().remove();
                
                // Update nodes
                const nodeSelection = this.nodeGroup
                    .selectAll(".node-group")
                    .data(nodesArray, d => d.id);
                
                const nodeEnter = nodeSelection.enter()
                    .append("g")
                    .attr("class", "node-group")
                    .call(d3.drag()
                        .on("start", this.dragstarted.bind(this))
                        .on("drag", this.dragged.bind(this))
                        .on("end", this.dragended.bind(this)));
                
                nodeEnter.append("circle")
                    .attr("class", d => {
                        let classes = `node ${d.type}`;
                        if (d.isVital) classes += ' vital';
                        else if (d.isFeatured) classes += ' featured';
                        else if (d.isGood) classes += ' good';
                        if (this.expandedNodes.has(d.id)) classes += ' expandable';
                        return classes;
                    })
                    .attr("r", d => {
                        if (d.type === "root") return 12;
                        if (d.isVital) return 10;
                        if (d.isFeatured) return 9;
                        if (d.isGood) return 8;
                        return d.type === "first-degree" ? 8 : 6;
                    })
                    .on("click", (event, d) => {
                        event.stopPropagation();
                        console.log(`üñ±Ô∏è Showing context menu for node: ${d.title}`);
                        this.showContextMenu(event, d);
                    });
                
                nodeEnter.append("text")
                    .attr("class", "node-label")
                    .attr("dy", d => d.type === "root" ? 20 : (d.type === "first-degree" ? 16 : 14))
                    .text(d => d.title.replace(/_/g, ' '))
                    .style("font-size", d => d.type === "root" ? "14px" : (d.type === "first-degree" ? "12px" : "10px"));
                
                // Add degree number display
                nodeEnter.append("text")
                    .attr("class", "node-degree")
                    .attr("dy", -5)
                    .text(d => d.degree)
                    .style("font-size", "10px")
                    .style("fill", "#FFD700")
                    .style("font-weight", "bold")
                    .style("text-anchor", "middle")
                    .style("pointer-events", "none")
                    .style("user-select", "none");
                
                nodeSelection.exit().remove();
                
                // Update simulation
                this.simulation.nodes(nodesArray);
                this.simulation.force("link").links(linksArray);
                this.simulation.alpha(1).restart();
                
                // Update simulation tick
                this.simulation.on("tick", () => {
                    this.linkGroup.selectAll(".link")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);
                    
                    this.nodeGroup.selectAll(".node-group")
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });
                
                // Update counters
                document.getElementById("node-count").textContent = this.nodes.size;
                document.getElementById("link-count").textContent = this.links.size;
            }
            
            dragstarted(event, d) {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            dragended(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            updateStatus(message) {
                const statusEl = document.getElementById("status");
                if (message === "Ready") {
                    statusEl.innerHTML = "Ready";
                } else {
                    statusEl.innerHTML = `<span class="loading"></span>${message}`;
                }
            }
            
            pause() {
                this.isPaused = true;
                this.updateStatus("Paused");
            }
            
            resume() {
                this.isPaused = false;
                this.processQueue();
            }
            
            reset() {
                this.nodes.clear();
                this.links.clear();
                this.processedArticles.clear();
                this.expandedNodes.clear();
                this.queue = [];
                this.isPaused = false;
                
                this.linkGroup.selectAll("*").remove();
                this.nodeGroup.selectAll("*").remove();
                
                this.init();
            }
            
            async loadNewRoot(articleTitle) {
                // Convert display name to Wikipedia title format
                const normalizedTitle = articleTitle.replace(/ /g, '_');
                console.log(`üîÑ Loading new root article: ${normalizedTitle}`);
                
                // Clear existing graph
                this.nodes.clear();
                this.links.clear();
                this.processedArticles.clear();
                this.expandedNodes.clear();
                this.queue = [];
                this.isPaused = false;
                
                // Remove existing visualization
                this.linkGroup.selectAll("*").remove();
                this.nodeGroup.selectAll("*").remove();
                
                // Set new root article
                this.startArticle = normalizedTitle;
                
                // Update input box to show normalized title
                const rootInput = document.getElementById("root-input");
                if (rootInput) {
                    rootInput.value = normalizedTitle.replace(/_/g, ' ');
                }
                
                // Start fresh initialization
                await this.init();
            }
        }
        
        // Global functions
        let graph;
        
        function resetGraph() {
            graph.reset();
        }
        
        function pauseResume() {
            const btn = document.getElementById("pause-btn");
            if (graph.isPaused) {
                graph.resume();
                btn.textContent = "Pause";
            } else {
                graph.pause();
                btn.textContent = "Resume";
            }
        }
        
        async function loadNewRoot() {
            const input = document.getElementById("root-input");
            const button = document.getElementById("go-button");
            const articleTitle = input.value.trim();
            
            if (!articleTitle) {
                alert("Please enter a Wikipedia article title");
                return;
            }
            
            // Disable button during loading
            button.disabled = true;
            button.textContent = "Loading...";
            
            // Load new root article
            await graph.loadNewRoot(articleTitle);
            
            // Re-enable button after a short delay
            setTimeout(() => {
                button.disabled = false;
                button.textContent = "Go";
            }, 1000);
        }
        
        // Initialize when page loads
        document.addEventListener("DOMContentLoaded", () => {
            graph = new WikipediaGraph();
            
            // Add Enter key support for root input
            const rootInput = document.getElementById("root-input");
            rootInput.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                    event.preventDefault();
                    loadNewRoot();
                }
            });
        });
        
        // Handle window resize
        window.addEventListener("resize", () => {
            if (graph) {
                graph.width = window.innerWidth;
                graph.height = window.innerHeight;
                graph.svg.attr("width", graph.width).attr("height", graph.height);
                graph.simulation.force("center", d3.forceCenter(graph.width / 2, graph.height / 2));
            }
        });
    </script>
</body>
</html>