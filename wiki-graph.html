<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wikipedia 2-Degree Link Graph</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #3d-graph { width: 100vw; height: 100vh; display: block; }
    #loading { position: absolute; top: 10px; left: 10px; background: #fff8; padding: 8px; border-radius: 4px; z-index: 10; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>
<body>
  <div id="loading">Loading graph...</div>
  <div id="debug-panel" style="position:fixed;top:10px;right:10px;z-index:20;background:#222;color:#fff;padding:10px;border-radius:6px;max-width:400px;font-size:14px;opacity:0.95;min-width:200px;display:none;"></div>
  <div id="3d-graph"></div>
  <script>
    // --- CONFIG ---
    const WIKI_BASE = 'https://en.wikipedia.org';
    const WIKI_API = 'https://en.wikipedia.org/w/api.php';
    const START_TITLE = 'Force-directed_graph_drawing'; // Hardcoded Wikipedia page title
    const START_PATH = '/wiki/' + START_TITLE;
    const MAX_FIRST_DEGREE = 8; // Lower for performance
    const MAX_SECOND_DEGREE = 4; // Lower for performance
    const MAX_INBOUND = 8; // Limit inbound links per node

    // --- HELPERS ---
    function isWikiLink(href) {
      return href && href.startsWith('/wiki/') &&
        !href.includes(':') && // skip special pages
        !href.includes('#');   // skip in-page anchors
    }

    // --- DEBUG PANEL ---
    function showDebug(msg) {
      const panel = document.getElementById('debug-panel');
      panel.style.display = 'block';
      panel.innerHTML = msg;
    }
    function hideDebug() {
      document.getElementById('debug-panel').style.display = 'none';
    }

    // Fetch links using Wikipedia API (CORS-friendly)
    async function fetchWikiLinksAPI(title, debugLabel) {
      showDebug(`<b>Fetching:</b> <a href='${WIKI_BASE + '/wiki/' + encodeURIComponent(title)}' target='_blank' style='color:#6cf;'>${title}</a><br><small>${debugLabel||''}</small>`);
      const url = `${WIKI_API}?action=parse&page=${encodeURIComponent(title)}&prop=links&format=json&origin=*`;
      const resp = await fetch(url);
      const data = await resp.json();
      if (!data.parse || !data.parse.links) return [];
      // Only keep links in the main namespace (ns=0)
      const links = data.parse.links
        .filter(l => l.ns === 0)
        .map(l => l['*']);
      // Deduplicate
      return Array.from(new Set(links));
    }

    // Fetch inbound links (pages that link to this page)
    async function fetchInboundLinksAPI(title, debugLabel) {
      const url = `${WIKI_API}?action=query&prop=linkshere&titles=${encodeURIComponent(title)}&format=json&origin=*&lhlimit=${MAX_INBOUND}`;
      const resp = await fetch(url);
      const data = await resp.json();
      const pages = data.query && data.query.pages ? Object.values(data.query.pages) : [];
      if (!pages.length || !pages[0].linkshere) return [];
      // Only keep links in the main namespace (ns=0)
      return pages[0].linkshere.filter(lh => lh.ns === 0).map(lh => lh.title);
    }

    async function buildLinks() {
      const links = [];
      const nodesSet = new Set();
      nodesSet.add(START_PATH);
      // 1st degree outbound
      const firstDegreeTitles = (await fetchWikiLinksAPI(START_TITLE, '1st degree')).slice(0, MAX_FIRST_DEGREE);
      const firstDegreePaths = firstDegreeTitles.map(t => '/wiki/' + t.replace(/ /g, '_'));
      for (const subTitle of firstDegreeTitles) {
        const subPath = '/wiki/' + subTitle.replace(/ /g, '_');
        links.push({ subURL: START_PATH, objURL: subPath });
        nodesSet.add(subPath);
      }
      // 1st degree inbound for START
      const inboundToStart = (await fetchInboundLinksAPI(START_TITLE, 'inbound to start')).slice(0, MAX_INBOUND);
      for (const inTitle of inboundToStart) {
        const inPath = '/wiki/' + inTitle.replace(/ /g, '_');
        links.push({ subURL: inPath, objURL: START_PATH });
        nodesSet.add(inPath);
      }
      // 2nd degree outbound and inbound for each 1st degree
      for (const subTitle of firstDegreeTitles) {
        const subPath = '/wiki/' + subTitle.replace(/ /g, '_');
        // Outbound
        try {
          const secondDegreeTitles = (await fetchWikiLinksAPI(subTitle, '2nd degree')).slice(0, MAX_SECOND_DEGREE);
          for (const objTitle of secondDegreeTitles) {
            const objPath = '/wiki/' + objTitle.replace(/ /g, '_');
            links.push({ subURL: subPath, objURL: objPath });
            nodesSet.add(objPath);
          }
        } catch (e) {}
        // Inbound
        try {
          const inboundToSub = (await fetchInboundLinksAPI(subTitle, 'inbound to 1st degree')).slice(0, MAX_INBOUND);
          for (const inTitle of inboundToSub) {
            const inPath = '/wiki/' + inTitle.replace(/ /g, '_');
            links.push({ subURL: inPath, objURL: subPath });
            nodesSet.add(inPath);
          }
        } catch (e) {}
      }
      hideDebug();
      return { links, nodes: Array.from(nodesSet) };
    }

    function toGraphData(links, nodes) {
      // Calculate degree for each node
      const degreeMap = {};
      nodes.forEach(id => degreeMap[id] = 0);
      links.forEach(({ subURL, objURL }) => {
        if (degreeMap[subURL] !== undefined) degreeMap[subURL]++;
        if (degreeMap[objURL] !== undefined) degreeMap[objURL]++;
      });
      // 3d-force-graph expects { nodes: [{id, label, degree}], links: [{source, target}] }
      return {
        nodes: nodes.map(id => ({
          id,
          label: decodeURIComponent(id.replace('/wiki/', '').replace(/_/g, ' ')),
          degree: degreeMap[id],
          val: Math.sqrt(degreeMap[id] + 1)
        })),
        links: links.map(({ subURL, objURL }) => ({ source: subURL, target: objURL }))
      };
    }

    // --- MAIN ---
    (async function() {
      document.getElementById('loading').textContent = 'Fetching Wikipedia links...';
      const { links, nodes } = await buildLinks();
      window.links = links; // Expose for debugging
      window.nodes = nodes;
      console.log('Wiki Graph Links:', links);
      console.log('Wiki Graph Nodes:', nodes);
      console.log(`Graph summary: ${nodes.length} nodes, ${links.length} links`);
      document.getElementById('loading').textContent = 'Rendering graph...';
      const graphData = toGraphData(links, nodes);
      const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .graphData(graphData)
        .nodeLabel(node => node.label)
        .linkLabel(link => link.source + ' → ' + link.target)
        .nodeAutoColorBy('id')
        .nodeVal('val')
        .nodeRelSize(4)
        .onNodeClick(node => {
          window.open(WIKI_BASE + node.id, '_blank');
        })
        .nodeThreeObjectExtend(true)
        .nodeThreeObject(node => {
          // 只添加caption sprite，不覆盖球体
          const fontSize = 24;
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          context.font = `${fontSize}px Arial`;
          const text = node.label;
          const width = Math.ceil(context.measureText(text).width);
          canvas.width = width;
          canvas.height = fontSize + 12;
          context.font = `${fontSize}px Arial`;
          context.fillStyle = '#fff';
          context.textBaseline = 'top';
          context.fillText(text, 0, 6);
          const texture = new window.THREE.CanvasTexture(canvas);
          const material = new window.THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            opacity: 0.75
          });
          const sprite = new window.THREE.Sprite(material);
          sprite.scale.set(width * 1.2, (fontSize + 12) * 1.2, 1);
          sprite.position.set(0, Math.sqrt(node.degree + 1) * 10 + 10, 0); // Offset above the ball
          sprite.visible = false; // 默认隐藏
          node._captionSprite = sprite;
          return sprite;
        });

      let hoveredNode = null;
      Graph.onNodeHover(node => {
        hoveredNode = node;
      });

      // Update caption visibility and opacity every 100ms
      setInterval(() => {
        const camera = Graph.camera();
        Graph.graphData().nodes.forEach(node => {
          if (!node.__threeObj) return;
          // Node sphere opacity
          const nodeMat = node.__threeObj.material;
          if (nodeMat) {
            let dist = camera.position.distanceTo(node.__threeObj.position);
            let opacity = 0.75 - Math.min(dist, 1000) / 2000; // 0.75 near, ~0.25 far
            opacity = Math.max(0.2, Math.min(0.75, opacity));
            nodeMat.opacity = opacity;
            nodeMat.transparent = true;
            nodeMat.needsUpdate = true;
          }
          // Caption visibility and opacity
          if (!node._captionSprite) return;
          // Show if hovered, root, hub, or camera close
          let show = hoveredNode && hoveredNode.id === node.id;
          if (!show) show = node.id === START_PATH;
          if (!show) show = node.degree >= 6;
          if (!show) {
            const pos = node.__threeObj.position;
            const dist = camera.position.distanceTo(pos);
            if (dist < 300) show = true;
          }
          node._captionSprite.visible = show;
          if (show) {
            let dist = camera.position.distanceTo(node.__threeObj.position);
            let opacity = 0.75 - Math.min(dist, 1000) / 2000;
            opacity = Math.max(0.2, Math.min(0.75, opacity));
            node._captionSprite.material.opacity = opacity;
            node._captionSprite.material.needsUpdate = true;
          }
        });
      }, 100);
      document.getElementById('loading').style.display = 'none';
    })();
  </script>
</body>
</html> 